import type {AccountId} from '@shared/types/accounts.types';
import type {
  FeedSource,
  FeedSourceWithUrl,
  IntervalFeedSource,
} from '@shared/types/feedSources.types';
import type {IconName} from '@shared/types/icons.types';
import type {KeyboardShortcutId} from '@shared/types/shortcuts.types';
import type {TagId} from '@shared/types/tags.types';
import type {BaseStoreItem} from '@shared/types/utils.types';

/**
 * Strongly-typed type for a {@link FeedItem}'s unique identifier. Prefer this over plain strings.
 */
export type FeedItemId = string & {readonly __brand: 'FeedItemIdBrand'};

/**
 * The type of content in a feed item. Some types persist additional data (e.g. XKCD stores the
 * comic number, YouTube stores the video ID).
 */
export enum FeedItemContentType {
  Article = 'ARTICLE',
  Video = 'VIDEO',
  Website = 'WEBSITE',
  Tweet = 'TWEET',
  Xkcd = 'XKCD',
  YouTube = 'YOUTUBE',
  /** Feed items emitted by an interval feed subscription. */
  Interval = 'INTERVAL',
}

/**
 * The basic unit of content in the app. Generated by a {@link FeedSource} and can come in many
 * different content types.
 */
interface BaseFeedItem extends BaseStoreItem {
  /** Unique ID for this feed item. */
  readonly feedItemId: FeedItemId;
  /** Source of the feed item (e.g. RSS feed, YouTube channel, extension, ). */
  readonly feedSource: FeedSource;
  /** ID of the account that owns the feed item. */
  readonly accountId: AccountId;
  /** State of the feed item's import process. */
  readonly importState: FeedItemImportState;
  /** Data about the content of the feed item (e.g. title, URL, summary). */
  readonly content: FeedItemContent;
  /**
   * Triage status determines where the feed item "lives" in the app.
   *
   * Unlike tags which represent boolean states, these statuses form an exclusive set.
   */
  readonly triageStatus: TriageStatus;

  /**
   * Feed item state needs to allow for:
   * - quick reads and writes.
   * - indexing of arbitrary boolean states.
   *
   * To accomplish this, most state is stored as tags that either exist in this map or not.
   */
  readonly tagIds: Partial<Record<TagId, true>>;
}

type ArticleFeedItem = BaseFeedItem & {
  readonly content: ArticleFeedItemContent;
  readonly feedSource: FeedSourceWithUrl;
};

type VideoFeedItem = BaseFeedItem & {
  readonly content: VideoFeedItemContent;
  readonly feedSource: FeedSourceWithUrl;
};

type WebsiteFeedItem = BaseFeedItem & {
  readonly content: WebsiteFeedItemContent;
  readonly feedSource: FeedSourceWithUrl;
};

type TweetFeedItem = BaseFeedItem & {
  readonly content: TweetFeedItemContent;
  readonly feedSource: FeedSourceWithUrl;
};

type YouTubeFeedItem = BaseFeedItem & {
  readonly content: YouTubeFeedItemContent;
  readonly feedSource: FeedSourceWithUrl;
};

export type XkcdFeedItem = BaseFeedItem & {
  readonly content: XkcdFeedItemContent;
  readonly feedSource: FeedSourceWithUrl;
};

export type IntervalFeedItem = BaseFeedItem & {
  readonly content: IntervalFeedItemContent;
  readonly feedSource: IntervalFeedSource;
};

export type FeedItem =
  | ArticleFeedItem
  | VideoFeedItem
  | WebsiteFeedItem
  | TweetFeedItem
  | YouTubeFeedItem
  | XkcdFeedItem
  | IntervalFeedItem;

interface BaseFeedItemContent {
  /** Type of feed item content (e.g. article, video, website). */
  readonly feedItemContentType: FeedItemContentType;
  /** Title of the content provided by the source. */
  readonly title: string;
}

export interface BaseFeedItemContentWithUrl extends BaseFeedItemContent {
  /** URL of the source content. */
  readonly url: string;
  /** Description of the source content, provided by the source. */
  readonly description: string | null;
  /** Links found in the source content. */
  readonly outgoingLinks: string[];
  /** AI-generated summary of the source content. */
  readonly summary: string | null;
}

interface ArticleFeedItemContent extends BaseFeedItemContentWithUrl {
  readonly feedItemContentType: FeedItemContentType.Article;
}

interface VideoFeedItemContent extends BaseFeedItemContentWithUrl {
  readonly feedItemContentType: FeedItemContentType.Video;
}

interface WebsiteFeedItemContent extends BaseFeedItemContentWithUrl {
  readonly feedItemContentType: FeedItemContentType.Website;
}

interface TweetFeedItemContent extends BaseFeedItemContentWithUrl {
  readonly feedItemContentType: FeedItemContentType.Tweet;
}

interface YouTubeFeedItemContent extends BaseFeedItemContentWithUrl {
  readonly feedItemContentType: FeedItemContentType.YouTube;
}

export interface XkcdFeedItemContent extends BaseFeedItemContentWithUrl {
  readonly feedItemContentType: FeedItemContentType.Xkcd;
  readonly altText: string;
  readonly imageUrlSmall: string;
  readonly imageUrlLarge: string;
}

export interface IntervalFeedItemContent extends BaseFeedItemContent {
  readonly feedItemContentType: FeedItemContentType.Interval;
  readonly intervalSeconds: number;
}

export type FeedItemContent =
  | ArticleFeedItemContent
  | VideoFeedItemContent
  | WebsiteFeedItemContent
  | TweetFeedItemContent
  | YouTubeFeedItemContent
  | XkcdFeedItemContent
  | IntervalFeedItemContent;

export enum TriageStatus {
  Untriaged = 'UNTRIAGED',
  Saved = 'SAVED',
  Done = 'DONE',
  Trashed = 'TRASHED',
}

export enum FeedItemImportStatus {
  /** Created but not yet processed. */
  New = 'NEW',
  /** Currently being processed. */
  Processing = 'PROCESSING',
  /** Errored while processing. May have partially imported data. */
  Failed = 'FAILED',
  /** Successfully imported all data. */
  Completed = 'COMPLETED',
}

interface BaseFeedItemImportState {
  readonly status: FeedItemImportStatus;
  readonly shouldFetch: boolean;
  readonly lastImportRequestedTime: Date;
  readonly lastSuccessfulImportTime: Date | null;
}

export interface NewFeedItemImportState extends BaseFeedItemImportState {
  readonly status: FeedItemImportStatus.New;
  readonly shouldFetch: true;
  readonly lastSuccessfulImportTime: null;
}

interface ProcessingFeedItemImportState extends BaseFeedItemImportState {
  readonly status: FeedItemImportStatus.Processing;
  readonly shouldFetch: false;
  readonly importStartedTime: Date;
  readonly lastSuccessfulImportTime: Date | null;
}

interface FailedFeedItemImportState extends BaseFeedItemImportState {
  readonly status: FeedItemImportStatus.Failed;
  readonly shouldFetch: boolean;
  readonly errorMessage: string;
  readonly importFailedTime: Date;
  readonly lastSuccessfulImportTime: Date | null;
}

interface CompletedFeedItemImportState extends BaseFeedItemImportState {
  readonly status: FeedItemImportStatus.Completed;
  readonly shouldFetch: boolean;
  readonly lastSuccessfulImportTime: Date;
}

export type FeedItemImportState =
  | NewFeedItemImportState
  | ProcessingFeedItemImportState
  | FailedFeedItemImportState
  | CompletedFeedItemImportState;

export enum FeedItemActionType {
  Cancel = 'CANCEL',
  MarkDone = 'MARK_DONE',
  MarkUndone = 'MARK_UNDONE',
  MarkRead = 'MARK_READ',
  MarkUnread = 'MARK_UNREAD',
  Save = 'SAVE',
  Unsave = 'UNSAVE',
  Star = 'STAR',
  Unstar = 'UNSTAR',
  RetryImport = 'RETRY_IMPORT',
  Undo = 'UNDO',
}

export interface FeedItemAction {
  readonly actionType: FeedItemActionType;
  // TODO: Should this have `feedId` on it? Should it be optional?
  readonly text: string;
  readonly icon: IconName;
  readonly shortcutId?: KeyboardShortcutId;
}
